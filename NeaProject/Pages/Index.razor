@page "/"
@using System.Runtime.CompilerServices
@using Blazored.LocalStorage;
@using NeaProject.Engine
@using SkiaSharp;
@using SkiaSharp.Views.Blazor;
@using NeaProject.Classes;
@using System.Drawing;

@inject NavigationManager _navigationManager;
@inject ILocalStorageService _localStorage;

<div style="background-color:#955">
                <SKCanvasView 
                    OnPaintSurface="OnPaintSurface" 
                    IgnorePixelScaling="true"
                    EnableRenderLoop="true" 
                    style="width:640px; height:320px; margin:auto; display:block"/>
</div>

<div style="background-color:#559">
    @if (_player?.IsDead() == true)
    {
        <h1>YOU LOSE!!</h1>
    }
    else if (_player?.HasWon() == true)
    {
        <h1>YOU WIN!!</h1>
    }
    else
    {
        <table class="table-center">
            <tr>
                <td style="width:16%;" rowspan="2">wooa</td>
                <td rowspan="2">
                    @if (_player != null)
                    {
                        foreach (string? item in _player.Inventory)
                        {
                            <p>@item</p>
                        }
                    }
                 </td>
            <td style="width:8%">wooc</td>
            <td class="stat" style="width:8%">wood</td>
        </tr>
        <tr>
            <td>wooe</td>
            <td class ="stat">woof</td>
        </tr>
        <tr>
            <td rowspan="4"><img src="@($"{_navigationManager.Uri}images/player1.png")" style="width:100%" /></td>
            <td>@_navigationManager.Uri</td>
            <td rowspan="2">@_player?.Name</td>
            <td class="stat" rowspan="2">HP: @(_player?.CurrentHp ?? 0)</td>
        </tr>
        <tr>
            <td>wook</td>
        </tr>
        <tr>
            <td>wool</td>
            <td rowspan="2">woom</td>
            <td class="stat" rowspan="2">woon</td>
        </tr>
        <tr>
            <td>wooo</td>
        </tr>
    </table>
    }
</div>

<div>
    <button
        @ref="buttonRef"
        class="massive-invisible-button"
        @onkeydown="KeyDown">
        Pressed Key: @(lastPressed ?? "Nothing pressed yet")
    </button>
</div>

<div class="d-lg-none">
    <button @onclick="MoveUp">
        ↑
    </button>
    <button @onclick="MoveLeft">
        ←
    </button>
    <button @onclick="MoveDown">
        ↓
    </button>
    <button @onclick="MoveRight">
        →
    </button>
</div>
<div>
    <button class="massive-invisible-button" @onclick="SaveDataAsync">
        Save
    </button>
</div>
<div>
    <button class="massive-invisible-button" @onclick="ClearDataAsync">
        Delete Save Data
    </button>
</div>


@code {
    // Worth noting that the renderer is about 50% slower when you use Web GL. My assumption is that you end up
    // interop-ing more than it seems, another copy of the byte array for the surface would cause about the level of
    // slowdown I saw. But 2D canvas is fine - after all, just a 2D game.

    const int ViewportZoom = 1;
    const int ViewportWidth = 640 * ViewportZoom;
    const int ViewportHeight = 320 * ViewportZoom;

    private Map? _map;
    private Player? _player;
    private Dictionary<char, Sprite?>? _sprites;
    private FpsCounter? _fpsCounter;
    private Renderer? _renderer;
    private SKBitmap? _bitmap;
    private List<Npc> _npcs = new();
    private int currentCount = 0;
    private string? lastPressed;
    private ElementReference buttonRef;

    private void IncrementCount()
    {
        currentCount++;
    }


    private async Task SaveDataAsync()
    {
        await _localStorage.SetItemAsync("player", _player);
    }

    private async Task ClearDataAsync()
    {
        await _localStorage.RemoveItemAsync("player");
    }

    // Movement
    private void MoveUp()
    { 
        if (_player == null || _player.IsDead() || _player.HasWon() || _map == null)
        {
            return;
        }
        _player.FrameIndex = 3;
        _player.Move(_map, 0, -1); 
    }
    private void MoveRight()
    { 
        if (_player == null || _player.IsDead() || _player.HasWon() || _map == null)
        {
            return;
        }
        _player.FrameIndex = 1;
        _player.Move(_map, 1, 0);
    }
    private void MoveDown()
    {
        if (_player == null || _player.IsDead() || _player.HasWon() || _map == null)
        {
            return;
        }
        _player.FrameIndex = 0;
        _player.Move(_map, 0, 1);
    }
    private void MoveLeft()
    {
        if (_player == null || _player.IsDead() || _player.HasWon() || _map == null)
        {
            return;
        }
        _player.FrameIndex = 2;
        _player.Move(_map, -1, 0);
    }

    private void KeyDown(KeyboardEventArgs keyEvent)
    {
        
        var pressedKey = keyEvent.Key;
        lastPressed = pressedKey;
        pressedKey = pressedKey.ToLower();
        switch (pressedKey)
        {
            case "arrowup":
            case "w":
                {
                    MoveUp();
                    break;
                }
            case "arrowdown":
            case "s":
                {
                    MoveDown();
                    break;
                }
            case "arrowleft":
            case "a":
                {
                    MoveLeft();
                    break;
                }
            case "arrowright":
            case "d":
                {
                    MoveRight();
                    break;
                }
            default:
                {
                    break;
                }

        }
    }

    protected override async Task OnInitializedAsync()
    {
        Uri tileSheetUri = new Uri($"{_navigationManager.Uri}images/MapTiles/all_tiles.png"); // absolute for now, should be relative
        Uri mapUri = new Uri($"{_navigationManager.Uri}map-data/map_0.txt");
        string mapString = await DownloadAsync(mapUri);
        _map = new Map(mapString);
        if (await _localStorage.ContainKeyAsync("player"))
        {
            _player = await _localStorage.GetItemAsync<Player>("player");
        }
        else
        {
            _player = new Player
                {
                    CurrentHp = 100,
                    XPos = _map.Width / 2,
                    YPos = _map.Height / 2,
                    Name = "Mellie",
                    AllowedTiles = new List<char> { 'g', 's', 'w' }
                };
        }
        ImageLoader imageLoader = new ImageLoader();
        SKBitmap mapTileSheet = await ImageLoader.GetBitmapAsync(tileSheetUri);
        _sprites = new Dictionary<char, Sprite?>()
        {
            { '.', null},
            { 'd', new Sprite(mapTileSheet, "Diamond", 1)},
            { 'g', new Sprite(mapTileSheet, "Grass", 1)},
            { 'p', new Sprite(mapTileSheet, "Player", 4)},
            { 'r', new Sprite(mapTileSheet, "Rock", 1)},
            { 's', new Sprite(mapTileSheet, "Sand", 1)},
            { 'w', new Sprite(mapTileSheet, "Water", 1)}
        };

        _fpsCounter = new FpsCounter();
        _renderer = new Renderer(_map, _player, _sprites, ViewportWidth, ViewportHeight);
        _bitmap = new SKBitmap(ViewportWidth, ViewportHeight);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await buttonRef.FocusAsync();
        }
    }

    protected void OnPaintSurface(SKPaintSurfaceEventArgs e)
    {
        if (_renderer == null || _bitmap == null || _fpsCounter == null)
        {
            return;
        }
        // Their is a good article on the different ways to update pixel data here:
        //  https://docs.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/graphics/skiasharp/bitmaps/pixel-bits
        // Having tried them all maintaining and then setting the pixel byte array is the most performant for us.
        
        unsafe
        {
            fixed (uint* ptr = _renderer.UpdateFrameBuffer())
            {
                _bitmap.SetPixels((IntPtr)ptr);
            }
        }
        
        var canvas = e.Surface.Canvas;
        canvas.Clear(SKColors.White);
        canvas.DrawBitmap(_bitmap, new SKRect(0, 0, ViewportWidth*1, ViewportHeight*1));
        var fps = _fpsCounter.GetCurrentFps();
        using var paint = new SKPaint
        {
            IsAntialias = true,
            StrokeWidth = 5f,
            StrokeCap = SKStrokeCap.Round,
            TextAlign = SKTextAlign.Center,
            TextSize = 24,
        };

        var surfaceSize = e.Info.Size;
        canvas.DrawText($"{fps:0.00}fps", surfaceSize.Width / 2, surfaceSize.Height - 10f, paint);
    }

    public async static Task<string> DownloadAsync(Uri uri)
    {
        using var client = new HttpClient();
        var content = await client.GetStringAsync(uri);
        return content;
    }
    
    
}